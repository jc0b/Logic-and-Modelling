\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{proof, environ, array}
\usepackage{fitch}

\newcommand{\rulename}[1]{#1}
\newcommand{\hint}[1]{#1}
\newcommand{\myex}[2]{\exists #1 #2}
\newcommand{\myall}[2]{\forall #1 #2}

\title{Logic and Modelling Cheatsheet}
\author{Jacob Burley, Harry King}
\date{Block 5 2018}

\begin{document}

\maketitle

\section*{Propositional Logic Basics}
\begin{itemize}
    \item Contingency: formula is sometimes True, sometimes False.
    \item Tautology: formula is always True.
    \item Contradiction: formula is always False.
\end{itemize}

\subsection*{Semantic Entailment ($\vDash$)}

\[
\alpha_{1},\ldots,\alpha_{n}\vDash\beta.
\]
Whenever $\alpha_{1},\ldots\alpha_{n}$ are all true, $\beta$ is true.

\subsection*{Semantic Equivalence}

Formulae are logically equivalent if they have the same truth table.
$\phi\equiv\psi$.

\[
\alpha\equiv\beta\Longleftrightarrow\alpha\vDash\beta\,\,\,and\,\,\,\beta\vDash\alpha
\]

\section*{Natural Deduction}
$$\alpha_{1},\ldots,\alpha_{n}\vdash\beta$$

$\perp$ (turnstile) says that there is a natural deduction derivation
for $\beta$ given the premises $\alpha_{1},\ldots,\alpha_{n}$.
\\This means that, using the rules for natural deduction given below, we can derive $\beta$ from the given premises $\alpha_1,\ldots, \alpha_n$.

\section*{Soundness \& Completeness in Propositional Logic}

\subsection*{Semantic Entailment}

$\phi_{1},\ldots,\phi_{n}\vDash\psi.$

\subsection{Syntatic Derivability}

$\phi_{1},\ldots,\phi_{n}\vdash\psi$.

\subsection{Soundness/Correctness}

Everything derivable is true.

\[
\phi_{1},\ldots,\phi_{n}\vdash\psi\,\,\,\Longrightarrow\,\,\,\phi_{1},\ldots,\phi_{n}\vDash\psi
\]
\begin{itemize}
    \item If $\psi$ is derivable from premises $\phi_{1,}\ldots,\phi_{n}$, then every valuation that makes $\psi$ true.
    \item Truth in a model (valuation) is preserved under derivation.
    \item Correct/sound as it is not possible to derive false conclusions from true premises.
\end{itemize}

\subsection{Completeness}

Everything true is derivable.

\[
\phi_{1},\ldots,\phi_{n}\vDash\psi\,\,\,\Longrightarrow\,\,\,\phi_{1},\ldots,\phi_{n}\vdash\psi
\]
\begin{itemize}
    \item If $\psi$ follows semantically from $\phi_{1,}\ldots,\phi_{n}$, then $\psi$ can be derived syntatically from presmises $\phi_{1,}\ldots,\phi_{n}$.
    \item Thus syntactic derivation rules are strong enough to derive every semantic conclusion.
    \item The system is complete: no more rules are required.
\end{itemize}

\subsection{Soundness/Completeness Theorem}

\[
\phi_{1},\ldots,\phi_{n}\vdash\psi\,\,\,\Longleftrightarrow\,\,\,\phi_{1},\ldots,\phi_{n}\vDash\psi
\]

\section*{Propositional Logic Rules}

\subsection*{Introduction of $\wedge$}
    \begin{align*}
      \infer[\rulename{\wedge_i}]
      {\alpha \wedge \beta}
      {\alpha && \beta}
    \end{align*}
    (If you have derived $\alpha$ and $\beta$, then you can conclude $\alpha \wedge \beta$.)
\subsection*{Elimination of $\wedge$}
    \begin{align*}
      \infer[\rulename{\wedge_{e_1}}]
      {\alpha}
      {\alpha \wedge \beta}
      &&
      \infer[\rulename{\wedge_{e_2}}]
      {\beta}
      {\alpha \wedge \beta}
    \end{align*}

\subsection*{Introduction of $\vee$}
    \begin{align*}
      \infer[\rulename{\vee_{i_1}}]
      {\alpha \vee \beta}
      {\alpha}&&
      \infer[\rulename{\vee_{i_2}}]
      {\alpha \vee \beta}
      {\beta}
    \end{align*}
    
\subsection*{Elimination and introduction of $\neg\neg$}
    \begin{align*}
      \infer[\rulename{\neg\neg_e}]
      {\alpha}
      {\neg\neg\alpha}
      &&
      \infer[\rulename{\neg\neg_i}]
      {\neg\neg\alpha}
      {\alpha}
    \end{align*}
    
\subsection*{Elimination with $\to$}
    This rule is called ``Modus Ponens'' (MP):
    \begin{align*}
      \infer[\rulename{\to_e} (or \rulename{MP})]
      {\beta}
      {\alpha && \alpha \to \beta}
    \end{align*}
    (If we have derived $\alpha$ and we know that $\alpha\to\beta$, then you can conclude $\beta$.)
    \\\\This rule is called ``Modus Tollens'' (MT):
    \begin{align*}
      \infer[\rulename{MT}]
      {\neg\alpha}
      {\alpha \to \beta && \neg\beta}
    \end{align*}
    (If we have derived $\alpha \to \beta$ and we know that $\beta$ is false ($\neg\beta$), then you can conclude $\alpha$ is false ($\neg\alpha$).)
    
\subsection*{Introduction with $\to$}
    \begin{align*}
      \infer[\rulename{\to_i}]
      {\alpha \to \beta}
      {
        \framebox{\parbox{.8cm}{\centerline{$\alpha$}\centerline{$\vdots$}\centerline{$\beta$}}}
      }
    \end{align*}
    (Basically, if we make an assumption $\alpha$, and we can use the above rules to conclude $\beta$, then we can say that $\alpha\to\beta$.)
    
\subsection*{Copy rule}
    \begin{align*}
      \infer[\rulename{copy}]
      {\alpha}
      {\alpha}
    \end{align*}
    (Basically we can copy an $\alpha$ to where we want it to be if we would like to.)

\subsection*{Elimination and introduction with $\neg$}
    \begin{align*}
      \infer[\rulename{\neg_e}]
      {\bot}
      {\alpha && \neg \alpha}
    \end{align*}
    (Given a premise $\alpha$ and an instance of $\neg\alpha$, we can say that this is the same as $\bot$)
    
    \begin{align*}
      \infer[\rulename{\neg_i}]
      {\neg \alpha}
      {
        \framebox{\parbox{.8cm}{\centerline{$\alpha$}\centerline{$\vdots$}\centerline{$\bot$}}}
      }
    \end{align*}
    (If from a instance $\alpha$ we can derive $\bot$, we can say that this is the same as $\neg\alpha$)
    
\subsection*{Bottom (false) elimination}
    \begin{align*}
      \infer[\rulename{\bot_e}]
      {\alpha}
      {\bot}
    \end{align*}
    
\subsection*{Disjunction Elimination}
    \begin{align*}
      \infer[\rulename{\vee_e}]
      {\gamma}
      {
        \alpha \vee \beta && 
        \framebox{\parbox{.8cm}{\centerline{$\alpha$}\centerline{$\vdots$}\centerline{$\gamma$}}} 
        &&
        \framebox{\parbox{.8cm}{\centerline{$\beta$}\centerline{$\vdots$}\centerline{$\gamma$}}} 
      }
    \end{align*}

\subsection*{Proof by Contradiction / Reductio ad Absurdum}
    \begin{align*}
        \infer[\rulename{PBC} \quad (or \rulename{RAA})]
      {\alpha}
      {\framebox{\parbox{.8cm}{\centerline{$\neg\alpha$}\centerline{$\vdots$}\centerline{$\bot$}}}}
    \end{align*}

\subsection*{Law of Excluded Middle}
    \vspace{3ex}
    \begin{align*}
       \infer[\rulename{LEM}]
      {\alpha \vee \neg \alpha}
      {
      } 
    \end{align*}
    (This rule does not have premises)
    
\section*{Predicate Logic Rules}
\subsection*{A quick note on "\textit{Free for $x$}"}
For some of the below rules, we replace all \textbf{free} instances of $x$ in $\phi$ with our new term $t$, but \textbf{only} if we are sure that variable $t$ is free for $x$ in $\phi$. 
    \\\\What is meant by "\textit{free for $x$}"? If we are introducing a term $t$ such as $F(y,y)$, then we would replace all $x$s in the parse tree for a formula $\phi$ with $F(y,y)$. However, we must not do this if the unbound $x$ we are replacing \textit{is} bound by, in this case, a quantification for $y$. If we did this, our new term $F(y,y)$ would be bound by this quantification, which we should avoid.
\subsection*{Introduction of Existential Quantification}
    \begin{align*}
      \infer[\rulename{\exists_i}]
      {\myex{x}{\phi}}
      {\phi\;[t/x]}
    \end{align*}
    (The condition for applying this rule is that the variable $t$ is free for $x$ in $\phi$) %%aka not bound by another quantifier? I think this means?

\subsection*{Elimination of Universal Quantification}
    \begin{align*}
      \infer[\rulename{\forall_e}]
      {\phi\;[t/x]}
      {\myall{x}{\phi}}
    \end{align*}
    (The condition for applying this rule is that variable $t$ is free for $x$ in $\phi$)
\subsection*{Introduction of Universal Quantification}
    \begin{equation*}
      \infer[\rulename{\forall_i}]
      {\forall x \phi}
      {
        \framebox{\parbox{1.8cm}{\hint{$x_0$}
        \centerline{\vdots}
        \centerline{$\phi[x_0/x]$}}}
      }
    \end{equation*}
    (The condition for the application of this rule is that $x_0$ is arbitrary: that is, that $x_0$ only occurs within the box, we cannot remove it from the box and use it in $\phi$)
    
\subsection*{Elimination of Existential Quantification}
    \begin{align*}
      \infer[\rulename{\exists_e}]
      {\psi}
      {
        \myex{x}{\phi} &&
        \framebox{\parbox{1.8cm}{\hint{$x_0$}\\\centerline{$\phi[x_0/x]$}\\\centerline{$\vdots$}\\\centerline{$\psi$}}}
      }
    \end{align*}
    (Condition for application of this rule is that $x_0$ is nowhere outside this box, i.e. it is not used in $\psi$)
\section*{Predicate Logic with Equality}
  \subsection*{Equality Introduction}
    \begin{align*}
      \infer[\rulename{=_i}]
      {\quad t=t \quad}
      {}
    \end{align*}
    There are no prerequisites here, we can simply add an equality stating that a term $t$ is equal to term $t$.
  \subsection*{Equality Elimination}
    \begin{align*}
      \infer[\rulename{=_e}]
      {\phi[t_2/x]}
      {t_1 = t_2 && \phi[t_1/x]}
    \end{align*}
    Given that $t_1$ is free for $x$ in $\phi$, and $t_1 = t_2$, we can replace all instances of $t_1$ with $t_2$.
    
\end{document}